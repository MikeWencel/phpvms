# This Docker Compose file is an example of what a setup for running phpVMS in production could look like.
# It is based on the image created in the Dockerfile. You can find more examples in phpvms' documentation.
services:
  app:
    container_name: phpvms-app
    user: "${WWWUSER:-1000}:${WWWGROUP:-1000}"
    image: ghcr.io/phpvms/phpvms:main
    # build:
    #   context: .
    #   dockerfile: Dockerfile
    #   args:
    #     WWWUSER: "${WWWUSER:-1000}"
    #     WWWGROUP: "${WWWGROUP:-1000}"
    hostname: app
    restart: unless-stopped
    environment:
      PHP_OPCACHE_ENABLE: 1
      # some basic laravel stuff
      AUTORUN_ENABLED: 1
    env_file: .env
    volumes:
      - phpvms_assets:/var/www/html/public/build:rw
      - ./modules:/var/www/html/modules:ro
      - phpvms_uploads:/var/www/html/public/uploads:rw
      - phpvms_storage:/var/www/html/storage:rw
    depends_on:
      - mariadb
      - redis
    networks:
      - phpvms

  task:
    container_name: phpvms-task
    user: "${WWWUSER:-1000}:${WWWGROUP:-1000}"
    image: ghcr.io/phpvms/phpvms:main
    # build:
    #   context: .
    #   dockerfile: Dockerfile
    #   args:
    #     WWWUSER: "${WWWUSER:-1000}"
    #     WWWGROUP: "${WWWGROUP:-1000}"
    restart: unless-stopped
    command: ["php", "/var/www/html/artisan", "schedule:work"]
    environment:
      PHP_OPCACHE_ENABLE: 1
    healthcheck:
      # This is our native healthcheck script for the scheduler
      test: [ "CMD", "healthcheck-schedule" ]
      start_period: 10s
    env_file: .env
    volumes:
      - ./modules:/var/www/html/modules:ro
      - phpvms_uploads:/var/www/html/public/uploads:rw
      - phpvms_storage:/var/www/html/storage:rw
    depends_on:
      - app
    networks:
      - phpvms

  queue:
    container_name: phpvms-queue
    user: "${WWWUSER:-1000}:${WWWGROUP:-1000}"
    image: ghcr.io/phpvms/phpvms:main
    # build:
    #   context: .
    #   dockerfile: Dockerfile
    #   args:
    #     WWWUSER: "${WWWUSER:-1000}"
    #     WWWGROUP: "${WWWGROUP:-1000}"
    restart: unless-stopped
    command: [ "php", "/var/www/html/artisan", "queue:work", "--tries=3" ]
    environment:
      PHP_OPCACHE_ENABLE: 1
    healthcheck:
      # This is our native healthcheck script for the queue
      test: [ "CMD", "healthcheck-queue" ]
      start_period: 10s
    env_file: .env
    volumes:
      - ./modules:/var/www/html/modules:ro
      - phpvms_uploads:/var/www/html/public/uploads:rw
      - phpvms_storage:/var/www/html/storage:rw
    depends_on:
      - app
    networks:
      - phpvms

  nginx:
    container_name: phpvms-nginx
    image: nginx:alpine
    restart: unless-stopped
    depends_on:
      - app
    volumes:
      - ./public/:/var/www/html/public:ro
      - phpvms_assets:/var/www/html/public/build:ro
      - phpvms_uploads:/var/www/html/public/uploads:ro
      - ./resources/docker/nginx.conf:/etc/nginx/conf.d/default.conf:ro
    networks:
      - default
      - phpvms
      - production_traefik-prod-web

  mariadb:
    container_name: phpvms-mariadb
    image: mariadb:11
    restart: unless-stopped
    # If someone need to access db from the outside
    # ports:
    #   - '${FORWARD_DB_PORT:-3306}:3306'
    environment:
      MYSQL_ROOT_PASSWORD: 'hello'
      MYSQL_DATABASE: 'hello'
      MYSQL_USER: 'hello'
      MYSQL_PASSWORD: 'hello'
      MYSQL_ALLOW_EMPTY_PASSWORD: 'no'
    volumes:
      - ./docker-data/mariadb:/var/lib/mysql
    networks:
      - phpvms
    healthcheck:
      test: ["CMD", "healthcheck.sh", "--connect", "--innodb_initialized"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 3

  redis:
    container_name: phpvms-redis
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - ./docker-data/redis:/data
    networks:
      - phpvms
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      retries: 3
      timeout: 5s

volumes:
  caddy_config:
  phpvms_assets:
  phpvms_uploads:
  phpvms_storage:

networks:
  phpvms:
    driver: bridge
  production_traefik-prod-web:
    external: true
  
